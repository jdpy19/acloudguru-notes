Introduction to CI/CD
  What is CI/CD?
    Software Development Best Practice
      continuous integration, continuous delivery/deployment
    Make small changes & automate everything!
      Small, incremental code changes. Autoamte as much as possible
        Code integration, build, test, and deployment

    Why is it so cool?
      Modern companies like AWS, Netflix, Google and Facebook have pioneered this approach to releasing code, successfully applying thousands of changes per day.

  Benefits of the CI/CD Approach
    Automation is good! Fast, repeatable, scalable, enables rapid deployment
    Manual is bad! Slow, error prone, inconsistent, unscalable, complex
    Small Changes: Test each code change and catch bugs while they are small and simple to fix.

  Continuous Integration Workflow
    Shared Code Repository: Multipler developers contributing to a shared code repository like Git. Frequently mergin or integrating code updates.
    Automated Build: When changes appear in the code repository this triggers an automated build of the new code.
    Automated Test: 

  Continuous Delivery & Deployment Workflow
    Code is Merged: After successful tests, the code gets merged to the master repository
    Prepared For Deployment: Code is built, tested and packaged for deployment
    Manual decision(continuous delivery) or fully automated (continuous deployment)

  AWS Developer Tools
    CodeCommit: Source & Version Control
      Source control service enabling teams to collaborate on code, html pages, scripts, images and binaries
    CodeBuild: Automated build service
      Compiles source code, runs tests and produces packages that are ready to deploy
    CodeDeploy: Automated Deployment
      Automates code deployments to any instance, including EC2, Lambda and on premises
    CodePipeline: Manages the workflow
      End-to-end solution, build, test and deploy your application every time there is a code change.

  Exam Tips:
    Continuous integration: Integrating or mergin the code changes frequently at least once per day: CodeCommit
    Continuous Delivery: Automating the build, test and deployment functions. Think CodeBuild and CodeDeploy
    Continuous Deployment: Fully autoamted release prcoess, code is deployed into Staging or Production as soon as it is successfully passed through the release pipeline. Think CodePipeline.

CodeCommit ~ Git Repository
  CodeCommit is a central code repository
    Source code, binaries, images, libraries
    Manages updates from multipler sources. enables collaboration
    Tracks and manages code changes. Manages version history.

  Exam Tips:
    Centralized Code Repository
    Enables Collaboration
    Version Control

CodeDeploy 101
  What is CodeDeploy?
    Automated Deployment
      EC2 Instances, on-premises & Lambda
        Quickly release new features
        Avoid downtime during deployments
        Avoid the risks associated with manual processes

  CodeDeploy Deployment Approaches
    In-Place: The application is stopped on each instance and the new release is installed. Also known as Rolling Update
      Capacity is reduced during the deployment
      Lambda is not supported
      Rolling back involves a re-deployment
      Great when deploying in the first time
    Blue/green: New instances are provisioned and the new release is installed on the new instances. Blue represents the active deployment, green is the new release.
      Safest option
      No capacity reduction
      Green instances can be created ahead of time
      Easy to switch between old and new
      You pay for 2 environments until you terminate the old servers
      Just redirect Load Balancer if a rollback is required, only works if old environment hasn't been terminated.

  CodeDeploy AppSpec File
    Configuration File: Defines the paramteres to be used during a CodeDeploy deployment
    EC2: For EC2 and on-prem, YAML only
    Lambda: YAML and JSON supported

    Version: Reserved for future use, currently 0.0
    OS: The operating sytem
    Files: the location of any application files that need to be copied and where they should be copied to
    Hooks: Scripts which need to run at set points in the deployment life cycle, have a specifc run order

    Script Examples:
      UZip Files: Unzip application files
      Run Tests
      Deal With Load Balancing: De-register, re-register instances with a load balancer

    Typical Folder Setup:
      appspec.yml
      /Scripts
      /Config
      /Source

  CodeDeploy Lifecycle Event Hooks
    Run in a specific order

    Phase 1
      De-register instances from a Load balancer
    Phase 2
      Nuts and bolts of the application deployment
    Phase 3
      Re-register instances with load balancer.

    BeforeBlockTraffic: Tasks you want to run on instances before they are deregistered from a Load Balancer
    BlockTraffic: De-register instances from a load balancer
    AfterBlockTraffic: Tasks you want to run on instances after they are de-registered from a load balancer

    ApplicationStop: Gracefully stop the application
    DownloadBundle: CodeDeploy agent copies the application revision files to a temporary location
    BeforeInstall: Pre-installation scripts, e.g. backin up the current version, decrypting files
    Install: Copy application revision files to final location
    AfterInstall: Post-install scripts e.g. configuration file permissions
    ApplicationStart: Start any services that were stopped during ApplicationStop
    ValidateService: Run tests to validate the service

    BeforeAllowTraffic: Tasks you want to run on instances before they are registered with the Load Balancer
    AllowTraffic: Register instances with a load balancer
    AfterAllowTraffic: Tasks you want to run on instances after they are registered with a Load Balancer

  Exam Tips
    Run Order: Lifecycle event hooks are run in a specific order known as the run order
    In-Place Deployment: Broadly 3 phases: De-registering, installation, re-registering with a load balancer
    Logical Flow

      
CloudFormation and SAM
  Serverless Application Model (SAM)
    CloudFormation for Serverless
      The Serverless Application Model (SAM) is an extension to CloudFormation used to define serverless applications
    Simplified Syntax
      SAM uses a simplified syntax for defining serverless resources: APIs, Lambda functions, DynamoDB tables, etc.
    SAM CLI
      Use the SAM CLI to package your deployment code, upload it to S3 and deploy your Serverless application.

    Commands:
      sam package --template-file ./mytemplate.yml --output-template-file sam-template.yml --s3-bucket s3-bucket-name
      sam deploy --template-file sam-template.yml --stack-name mystack --capabilities CAPABILITY_IAM

    Exam tips: 
      SAM = Serverless Application Model
      Define and provision serverless applications using CloudFormation
      Has its own api
      sam package: Pacakges your application and uploads to S3
      sam deploy: Deploy your serverless app using CloudFormation
      
  Demo: 
    Install the AWS SAM CLI on yuor local machine
    Create an S3 bucket
    Use sam package to package our code and save it in S3
    Use sam deploy to deploy your code from S3

  Nested Stacks
    Enable re-use of CloudFormation code for common use cases.
      E.g. standard configuration for a load balancer, web server, or application server.
      Instead of copying out the code each time, create a standard template for each common use case and reference from within your CloudFormation template.

